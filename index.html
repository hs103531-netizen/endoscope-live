<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endoscope AI (WebGPU/WASM)</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:16px;background:#f7fafc}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start}
    video,canvas{border:1px solid #ddd;border-radius:10px}
    #panel{display:flex;gap:12px;align-items:center;margin:8px 0}
    .card{background:#fff;border:1px solid #e2e8f0;border-radius:10px;padding:10px;min-width:120px}
    .k{font-size:12px;color:#64748b} .v{font-size:18px;font-weight:600}
    button{border:0;background:#2563eb;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
    button#stop{background:#ef4444}
    canvas#view{pointer-events:none}
  </style>
</head>
<body>
<h2>Endoscope AI – Browser Inference</h2>

<div class="row">
  <video id="cam" autoplay playsinline style="display:none"></video>
  <canvas id="view" width="960" height="720" style="width:960px; height:auto"></canvas>
</div>

<div id="panel">
  <button id="start">Start</button>
  <button id="stop">Stop</button>
  <div class="card"><div class="k">FPS</div><div class="v" id="fpsVal">0</div></div>
  <div class="card"><div class="k">Latency(ms)</div><div class="v" id="latVal">0</div></div>
  <div class="card"><div class="k">Conf(%)</div><div class="v" id="confVal">0</div></div>
  <div class="card"><div class="k">Conn</div><div class="v" id="connVal">대기중</div></div>
</div>

<script>
  const MODEL_URL_FP32 = "https://huggingface.co/jdi1009/endoscope-assets/resolve/main/inference_model.onnx";
  const LABELS_URL     = "https://huggingface.co/jdi1009/endoscope-assets/resolve/main/labels.json";

  let INPUT_W = 560, INPUT_H = 560;
  const MEAN=[0.485,0.456,0.406], STD=[0.229,0.224,0.225];
  const CONF_TH=0.1, NMS_IOU=0.5, TOPK=100; // threshold 낮춤
  const LOAD_TIMEOUT_MS = 120000;

  let inName="input", ORT=null, session=null, labels=["polyp"];

  const cam=document.getElementById('cam');
  const canvas=document.getElementById('view');
  const ctx=canvas.getContext('2d');
  const fpsEl=document.getElementById('fpsVal');
  const latEl=document.getElementById('latVal');
  const confEl=document.getElementById('confVal');
  const connEl=document.getElementById('connVal');
  const startBtn=document.getElementById('start');
  const stopBtn=document.getElementById('stop');

  let running=false, busy=false, raf=0, last=performance.now(), emaFps=0;

  function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s);});}
  async function ensureORT(){
    if (navigator.gpu) {
      try { await loadScript("https://cdn.jsdelivr.net/npm/onnxruntime-web/webgpu/ort.webgpu.min.js"); return window.ort; } catch(_) {}
    }
    await loadScript("https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js");
    return window.ort;
  }
  function cxcywh2xyxy(b,W=INPUT_W,H=INPUT_H){const[cx,cy,w,h]=b;return[(cx-w/2)*W,(cy-h/2)*H,(cx+w/2)*W,(cy+h/2)*H]}
  function iou(a,b){const[ax1,ay1,ax2,ay2]=a,[bx1,by1,bx2,by2]=b;const ix1=Math.max(ax1,bx1),iy1=Math.max(ay1,by1);const ix2=Math.min(ax2,bx2),iy2=Math.min(ay2,by2);const iw=Math.max(0,ix2-ix1),ih=Math.max(0,iy2-iy1);const inter=iw*ih;const u=(ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-inter+1e-6;return inter/u}
  function nms(d,thr=NMS_IOU){d.sort((a,b)=>b.score-a.score);const keep=[];for(const x of d){let ok=true;for(const y of keep){if(iou(x.xyxy,y.xyxy)>thr){ok=false;break}}if(ok)keep.push(x)}return keep}

  const P={W:0,H:0,cv:null,ox:null,hw:0,arr:null};
  function initPreprocess(W,H){
    P.W=W; P.H=H; P.hw=W*H;
    P.cv=(typeof OffscreenCanvas!=='undefined')?new OffscreenCanvas(W,H):(()=>{const c=document.createElement('canvas'); c.width=W; c.height=H; return c;})();
    P.ox=P.cv.getContext('2d',{willReadFrequently:true});
    P.arr=new Float32Array(3*P.hw);
  }
  function preprocess(video){
    const {W,H,ox,hw,arr}=P;
    ox.drawImage(video,0,0,W,H);
    const rgba=ox.getImageData(0,0,W,H).data;
    for(let i=0,j=0;i<hw;i++,j+=4){
      const r=rgba[j]/255,g=rgba[j+1]/255,b=rgba[j+2]/255;
      arr[i]=(r-MEAN[0])/STD[0];
      arr[i+hw]=(g-MEAN[1])/STD[1];
      arr[i+2*hw]=(b-MEAN[2])/STD[2];
    }
    return new ORT.Tensor('float32',arr,[1,3,H,W]);
  }

  const useVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
  function scheduleNext(){
    if(!running) return;
    if(useVFC) cam.requestVideoFrameCallback(()=>tick());
    else raf=requestAnimationFrame(()=>tick());
  }

  startBtn.addEventListener('click', async ()=>{
    if(running) return;
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{ facingMode:'environment', width:{ideal:640}, height:{ideal:480}, frameRate:{ideal:30, max:30} },
        audio:false
      });
      cam.srcObject = stream; await cam.play();
      connEl.textContent = session ? '연결됨' : '연결됨(모델 로딩중)';
      running=true; scheduleNext();
    }catch(e){
      console.error('[Camera] getUserMedia error', e);
      alert('카메라 권한을 허용해 주세요.');
    }
  });
  stopBtn.addEventListener('click', ()=>{
    running=false; cancelAnimationFrame(raf);
    cam.srcObject?.getTracks()?.forEach(t=>t.stop());
    ctx.clearRect(0,0,canvas.width,canvas.height);
    connEl.textContent='연결끊김'; fpsEl.textContent='0'; latEl.textContent='0'; confEl.textContent='0';
  });

  async function tick(){
    const tFrame=performance.now();
    if(!session || busy){
      ctx.drawImage(cam,0,0,canvas.width,canvas.height);
      if(!session) latEl.textContent='-';
      scheduleNext();
      return;
    }
    busy=true;
    const t0=performance.now();

    const feeds={};
    feeds[inName] = preprocess(cam);
    let out;
    try{ out = await session.run(feeds); }
    catch(e){ console.error('OrtRun error', e); connEl.textContent='추론 오류'; busy=false; scheduleNext(); return; }

    console.log("out keys:", Object.keys(out));

    const logitsT = out["pred_logits"] || out[Object.keys(out)[0]];
    const boxesT  = out["pred_boxes"]  || out[Object.keys(out)[1]];
    console.log("dims logits:", logitsT.dims, "dims boxes:", boxesT.dims);

    const logits = logitsT.data, boxes=boxesT.data;
    const Q=boxes.length/4; const C=logits.length/Q; const FG=Math.min(labels.length || (C-1), C);
    const exps=new Float32Array(C);

    const dets=[]; let maxScore=0;
    for(let q=0;q<Math.min(Q,TOPK);q++){
      const offs=q*C; let m=-1e9; for(let i=0;i<C;i++){ if(logits[offs+i]>m)m=logits[offs+i]; }
      let sum=0; for(let i=0;i<C;i++){ const v=Math.exp(logits[offs+i]-m); exps[i]=v; sum+=v; }
      let best=0, idx=0; for(let i=0;i<FG;i++){ const p=exps[i]/sum; if(p>best){best=p; idx=i;} }
      if(best<CONF_TH) continue;
      const xyxy=cxcywh2xyxy([boxes[q*4],boxes[q*4+1],boxes[q*4+2],boxes[q*4+3]], canvas.width, canvas.height);
      dets.push({xyxy,label:labels[idx]??String(idx),score:best}); if(best>maxScore) maxScore=best;
    }

    const final=nms(dets,NMS_IOU);

    ctx.drawImage(cam,0,0,canvas.width,canvas.height);
    ctx.lineWidth=2; ctx.font='14px system-ui';
    for(const d of final){
      const [x1,y1,x2,y2]=d.xyxy; ctx.strokeStyle='#18a058'; ctx.strokeRect(x1,y1,x2-x1,y2-y1);
      const tag=`${d.label} ${d.score.toFixed(2)}`; const tw=ctx.measureText(tag).width+6;
      ctx.fillStyle='rgba(24,160,88,0.9)'; ctx.fillRect(x1,Math.max(0,y1-18),tw,18);
      ctx.fillStyle='#fff'; ctx.fillText(tag,x1+3,Math.max(12,y1-4));
    }

    const inferMs=performance.now()-t0; latEl.textContent=inferMs.toFixed(1);
    const dt=tFrame-last; last=tFrame; const fps=1000/dt; emaFps=emaFps?emaFps*0.9+fps*0.1:fps; fpsEl.textContent=emaFps.toFixed(1);
    confEl.textContent=(maxScore*100).toFixed(1);

    busy=false; scheduleNext();
  }

  async function loadModelWithFallback(){
    ORT = await ensureORT();
    if(!navigator.gpu){
      ORT.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";
      ORT.env.wasm.simd = true;
      ORT.env.wasm.proxy = true;
      ORT.env.wasm.numThreads = Math.min(4, (navigator.hardwareConcurrency||2));
      if (!self.crossOriginIsolated) ORT.env.wasm.numThreads = 1;
    }
    try{ labels = await fetch(LABELS_URL).then(r=>r.json()); }catch(e){ console.warn('labels.json load fail', e); }

    connEl.textContent='모델 다운로드중';
    const buf = await fetch(MODEL_URL_FP32).then(r=>r.arrayBuffer());

    try{
      session = await ORT.InferenceSession.create(buf, { executionProviders: navigator.gpu?["webgpu","wasm"]:["wasm"], graphOptimizationLevel:'all' });
      initPreprocess(INPUT_W, INPUT_H);
      connEl.textContent='준비됨';
    }catch(e){
      console.error('Model load/init failed', e);
      connEl.textContent='모델 로딩 실패';
    }
  }

  (async ()=>{ await loadModelWithFallback(); })();
</script>
</body>
</html>
